#!/usr/bin/env bash
# wrapper script for urnn scripts and functions

# planned:
usage()
{
  echo "usage: $0 [retrain|regen|refresh|colors] (file) (file)"
  echo "       retrain               retrain urnn with the current dataset"
  # This will eventually have a (convert/colors) arg, for now using colors only.
  echo "       regen                 regenerate ALL urnn data from inputs (HEAVY operation)"
  echo "       refresh               repopulate urnn.data file from dataset(after an add, for example)"
  echo "       colors (img)          generate xresources to STDOUT using current training result"
  echo "       add (img) (Xres)      generate and add urnn data to current dataset(for quickly testing)"
  echo "       addinput (img) (Xres) generate and add urnn data to dataset, and add files to input/staging"
}

setup()
{
  [[ -f network/urnn_train ]] && return 0
  cd network
  cc urnn_train.c -o urnn_train -l fann -l m
  cc urnn_run.c -o urnn_run -l fann -l m -std=c99

  cd ../colors/sin_colors
  make
}

retrain()
{
  cd network
  ./urnn_train urnn.data urnn.trained
}

regen()
{
  urnnputs

  # clear out the current dataset.
  rm dataset/*.data

  # Make new dataset from input/data.
  cd scripts
  ./extracter.pl
  cd ..

  # repopulate urnn.data
  refresh
}

refresh()
{
  cd network

  # at top of urnn.data, we have:
  # <sets> <input nodes> <output nodes>
  # We're using top 10 colors from images, with 3 nodes for every color = 30
  # There are 18 Xresources colors (times 3 for color nodes) = 54 output nodes
  # and a set is a pair of image.data and resource data.
  sets=`find ../dataset/ -name "*.images.data" | wc -l`
  echo "$sets 30 54" > urnn.data
  for file in `ls ../dataset | sort`; do
    (cat ../dataset/$file; echo) >> urnn.data
  done
}

colors()
{
  file="$1"
  [[ -z "$file" ]] && usage && exit 1
  [[ ! -f "$file" ]] && echo "ERR: could not find $file" && exit 1

  # Is this a png file?
  if ! file "$file" | grep "PNG image data" > /dev/null; then
    type convert >/dev/null 2>&1 || { echo >&2 "File was not png. Unable to convert image to png file without imagemagick package."; exit 1; }
    convert "$file" "/tmp/urnn.png"
    file="/tmp/urnn.png"
  fi

  store="$(mktemp)"
  colors/sin_colors/colors -en 10 $file | scripts/convert_hex_to_val_2.pl -s 1 > $store
  network/urnn_run network/urnn.trained $store | xargs -n3 | scripts/convert_val_to_xresources_colors_2.pl -s 1 -n
}

# Add inputs to the dataset folder
# add (image file) (xresources file)
# extracts colors from png and xresources and adds to the dataset folder.
add()
{
  image_file="$file_rel/$1"
  xres_file="$file_rel/$2"
  [[ -z "$image_file" ]] && usage && exit 1
  [[ -z "$xres_file" ]] && usage && exit 1
  [[ ! -f "$image_file" ]] && echo "ERR: could not find $image_file" && exit 1

  # Is this a png image_file?
  if ! file "$image_file" | grep "PNG image data"; then
    type convert >/dev/null 2>&1 || { echo >&2 "image_file was not png. Unable to convert image to png image_file without imagemagick package."; exit 1; }
    convert "$image_file" "/tmp/urnn.png"
    image_file="/tmp/urnn.png"
  fi

  # pick a unique-ish name for the files we're making.
  filename="$USER_`date +%N`"

  cd scripts
  # Xresources
  ./extract_hex_from_xresources.pl "$xres_file" | ./convert_hex_to_val_2.pl -s 1 > ../dataset/${filename}.resources.data
  ../colors/sin_colors/colors -en 10 "$image_file" | ./convert_hex_to_val_2.pl -s 1 > ../dataset/${filename}.images.data

  cd ..
}

# Add inputs to the dataset folder, and also move them to the input staging folder.
addinput()
{
  # Get file locations and add them to the dataset folder
  add "$1" "$2"

  # Copy the files to input/staging folder.
  cp "$image_file" "inputs/staging/${filename}.png"
  cp "$xres_file" "inputs/staging/${filename}.resources"
  echo "Generated by $USER" > "inputs/staging/${filename}.txt"
}

urnnputs()
{
  if [ ! -d inputs/data ]; then
    echo "no input/data directory found, pulling urnnputs."
    git submodule init
    git submodule update
  fi
}

# Make things relative to dir this script resides in
file_rel=`pwd`
cd $(dirname $([ -L $0  ] && readlink -f $0 || echo $0))

setup
valid="retrain refresh regen colors add addinput"
[[ -z "$1" ]] && usage
[[ $valid =~ $1 ]] && $@ || usage
